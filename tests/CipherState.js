// Generated by LiveScript 1.5.0
/**
 * @package noise-c.wasm
 * @author  Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @license 0BSD
 */
(function(){
  var createLib, randombytes, test, ciphers, plaintexts, ads, key;
  createLib = require('..');
  randombytes = require('crypto').randomBytes;
  test = require('tape');
  ciphers = ['NOISE_CIPHER_CHACHAPOLY'];
  plaintexts = [new Uint8Array, Uint8Array.from(randombytes(10))];
  ads = [new Uint8Array, randombytes(256)];
  key = randombytes(32);
  createLib(function(lib){
    var i$, ref$, len$, cipher, ad, key, known_plaintext, known_ciphertext;
    for (i$ = 0, len$ = (ref$ = ciphers).length; i$ < len$; ++i$) {
      (fn$.call(this, ref$[i$]));
    }
    cipher = lib.constants.NOISE_CIPHER_CHACHAPOLY;
    ad = new Uint8Array;
    key = Buffer.from('672caf1690343dd69a993cea46901622f0140709b3f0f3c543f6ec9393a47a46', 'hex');
    known_plaintext = Buffer.from('2fb6c173fdf9a0dfbaa5', 'hex');
    known_ciphertext = Buffer.from('91d46bd475958c9e2ec8abaab7757bea81784783500ac6e8fe23', 'hex');
    test('CipherState: Check for encryption correctness', function(t){
      var cs1, ciphertext, cs2, plaintext;
      cs1 = lib.CipherState(cipher);
      cs1.InitializeKey(key);
      ciphertext = cs1.EncryptWithAd(ad, known_plaintext);
      t.equal(ciphertext.toString(), Uint8Array.from(known_ciphertext).toString(), 'Encrypted correctly');
      cs1.free();
      cs2 = lib.CipherState(cipher);
      cs2.InitializeKey(key);
      plaintext = cs2.DecryptWithAd(ad, known_ciphertext);
      t.equal(plaintext.toString(), Uint8Array.from(known_plaintext).toString(), 'Decrypted correctly');
      cs2.free();
      t.end();
    });
    test('CipherState: Nonce increment on failed decryption', function(t){
      var cs, plaintext;
      cs = lib.CipherState(cipher);
      cs.InitializeKey(key);
      try {
        cs.DecryptWithAd(ad, new Uint8Array(known_ciphertext.length));
      } catch (e$) {}
      plaintext = cs.DecryptWithAd(ad, known_ciphertext);
      t.equal(plaintext.toString(), Uint8Array.from(known_plaintext).toString(), 'Decrypted correctly');
      cs.free();
      t.end();
    });
    test('CipherState: SetNonce', function(t){
      var cs, ciphertext1, ciphertext2;
      cs = lib.CipherState(cipher);
      cs.InitializeKey(key);
      cs.EncryptWithAd(ad, known_plaintext);
      ciphertext1 = cs.EncryptWithAd(ad, known_plaintext);
      cs.free();
      cs = lib.CipherState(cipher);
      cs.InitializeKey(key);
      cs.SetNonce(1);
      ciphertext2 = cs.EncryptWithAd(ad, known_plaintext);
      cs.free();
      t.equal(ciphertext1.toString(), ciphertext2.toString(), 'Encrypted correctly');
      t.end();
    });
    function fn$(cipher){
      var i$, ref$, len$;
      for (i$ = 0, len$ = (ref$ = plaintexts).length; i$ < len$; ++i$) {
        (fn$.call(this, ref$[i$]));
      }
      function fn$(plaintext){
        var i$, ref$, len$;
        for (i$ = 0, len$ = (ref$ = ads).length; i$ < len$; ++i$) {
          (fn$.call(this, ref$[i$]));
        }
        function fn$(ad){
          test("CipherState: " + cipher + ", plaintext length " + plaintext.length + ", ad length " + ad.length, function(t){
            var cs1, ciphertext, ciphertext2, cs2, plaintext_decrypted, cs3, cs4;
            t.doesNotThrow(function(){
              cs1 = lib.CipherState(lib.constants[cipher]);
            }, "Constructor doesn't throw an error");
            t.equal(cs1.HasKey(), false, 'No key initially');
            cs1.InitializeKey(key);
            t.equal(cs1.HasKey(), true, 'Key was initialized');
            t.doesNotThrow(function(){
              ciphertext = cs1.EncryptWithAd(ad, plaintext);
            }, "EncryptWithAd() doesn't throw an error");
            t.equal(ciphertext.length, plaintext.length + cs1._mac_length, 'ciphertext length is plaintext length + MAC');
            if (plaintext.length) {
              t.notEqual(plaintext.toString(), ciphertext.slice(0, plaintext.length).toString(), 'Plaintext and ciphertext are different');
            }
            ciphertext2 = cs1.EncryptWithAd(ad, plaintext);
            t.notEqual(ciphertext.toString(), ciphertext2.toString(), "Subsequent encryption doesn't have the same result");
            cs1.free();
            t.throws(function(){
              cs1.EncryptWithAd(new Uint8Array, plaintext);
            }, Error, "CipherState shouldn't be usable after free() is called");
            cs2 = lib.CipherState(lib.constants[cipher]);
            cs2.InitializeKey(key);
            t.doesNotThrow(function(){
              plaintext_decrypted = cs2.DecryptWithAd(ad, ciphertext);
            }, "DecryptWithAd() doesn't throw an error");
            t.equal(plaintext.toString(), plaintext_decrypted.toString(), 'Plaintext decrypted correctly');
            t.throws(function(){
              cs2.DecryptWithAd(ad, ciphertext);
            }, Error, 'Subsequent decryption fails');
            cs3 = lib.CipherState(lib.constants[cipher]);
            cs3.InitializeKey(key);
            t.throws(function(){
              cs3.DecryptWithAd(randombytes(256), ciphertext);
            }, Error, 'Plaintext decryption with incorrect additional data fails');
            cs3.free();
            cs4 = lib.CipherState(lib.constants[cipher]);
            cs4.InitializeKey(key);
            t.throws(function(){
              cs4.DecryptWithAd(ad, randombytes(256));
            }, Error, 'Plaintext decryption with incorrect ciphertext fails');
            cs4.free();
            t.end();
          });
        }
      }
    }
  });
}).call(this);
